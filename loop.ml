(**************************************************************************)
(*                                                                        *)
(*  This file is part of Frama-C.                                         *)
(*                                                                        *)
(*  Copyright (C) 2013-2014                                               *)
(*    CEA (Commissariat à l'énergie atomique et aux énergies              *)
(*         alternatives)                                                  *)
(*                                                                        *)
(*  You may redistribute it and/or modify it under the terms of the GNU   *)
(*  Lesser General Public License as published by the Free Software       *)
(*  Foundation, version 2.1.                                              *)
(*                                                                        *)
(*  It is distributed in the hope that it will be useful, but WITHOUT     *)
(*  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    *)
(*  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General      *)
(*  Public License for more details.                                      *)
(*                                                                        *)
(*  See the GNU Lesser General Public License version 2.1 for more        *)
(*  details (enclosed in the file LICENSE).                               *)
(*                                                                        *)
(**************************************************************************)

open Cil_types
open Ast_const

(** Return True if the stmt list only contain 1 statement which is a Break *)
let else_is_break_only bstmts =
  List.length bstmts = 1 &&
  match (List.hd bstmts).skind with
  | Break _ -> true
  | _ -> false

(** Add a label in each loop, to see if we enter in it *)
let visitor mk_label = object(_)
      inherit Visitor.frama_c_inplace

      (** Pile qui stock le status des boucles *)
      val inLoopId = Stack.create ()

      val mutable first = false

      method! vfunc dec =
        if Annotators.shouldInstrument dec.svar then begin
          Cil.DoChildren
        end
        else
          Cil.SkipChildren

      method! vstmt_aux stmt =
        match stmt.skind with
        | If (e,th,el,l) ->
          (* If we are in the "If" created by Frama-c (hopefully) *)
          if not (Stack.is_empty inLoopId) && Stack.top inLoopId && else_is_break_only el.bstmts then begin
            ignore(Stack.pop inLoopId);
            Stack.push false inLoopId;
            let label = mk_label (Exp.one()) [] l in
            stmt.skind <- (If (e,{th with bstmts = label::th.bstmts},el,l));
            Cil.ChangeTo stmt
          end
          else
            Cil.DoChildren
        | Loop _ ->
          Stack.push true inLoopId;
          Cil.DoChildrenPost (fun stmt ->
              let st = Stack.pop inLoopId in
              if not st then
                stmt
              else begin (* If we did not find a If generated by Frama-c, simply add the labels at the start of the loop *)
                match stmt.skind with
                | Loop (ca,b,l,s1,s2) ->
                  let label = mk_label (Exp.one()) [] l in
                  {stmt with skind = Loop (ca,{b with bstmts = label::b.bstmts},l,s1,s2)}
                | _ -> assert false
              end
            )
         | _ ->
           Cil.DoChildren
    end

include Annotators.Register (struct

    let name = "LOOP"
    let help = "Loop Coverage"

    let apply mk_label ast =
      Visitor.visitFramacFileSameGlobals (visitor mk_label) ast
  end)
