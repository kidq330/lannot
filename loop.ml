(**************************************************************************)
(*                                                                        *)
(*  This file is part of Frama-C.                                         *)
(*                                                                        *)
(*  Copyright (C) 2013-2014                                               *)
(*    CEA (Commissariat à l'énergie atomique et aux énergies              *)
(*         alternatives)                                                  *)
(*                                                                        *)
(*  You may redistribute it and/or modify it under the terms of the GNU   *)
(*  Lesser General Public License as published by the Free Software       *)
(*  Foundation, version 2.1.                                              *)
(*                                                                        *)
(*  It is distributed in the hope that it will be useful, but WITHOUT     *)
(*  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    *)
(*  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General      *)
(*  Public License for more details.                                      *)
(*                                                                        *)
(*  See the GNU Lesser General Public License version 2.1 for more        *)
(*  details (enclosed in the file LICENSE).                               *)
(*                                                                        *)
(**************************************************************************)

open Cil_types
open Ast_const

let idsList = ref []

(** Return True if the stmt list only contain 1 statement which is a Break *)
let is_break_only bstmts =
  List.length bstmts = 1 &&
  match (List.hd bstmts).skind with
  | Break _ -> true
  | _ -> false

(** Add a label in each loop, to see if we enter in it *)
let inner mk_label = object(_)
  inherit Visitor.frama_c_inplace

  (** Pile qui stock le status des boucles *)
  val inLoopId = Stack.create ()

  method! vfunc dec =
    if Annotators.shouldInstrument dec.svar then
      Cil.DoChildren
    else
      Cil.SkipChildren

  method! vstmt_aux stmt =
    match stmt.skind with
    | Loop (_,_,l,_,_) ->
      let label = mk_label (Exp.one()) [] l in
      Cil.DoChildrenPost (fun stmt ->
          begin
            match stmt.skind with
            | Loop (ca,b,l,s1,s2) ->
              let first = ref true in
              let f s =
                match s.skind with
                | If (e,th,el,l) ->
                  if !first && th.bstmts = [] && is_break_only el.bstmts then begin
                    s.skind <- (If (e,{th with bstmts = [label]},el,l));
                    first := false
                  end;
                  s
                | _ -> s
              in
              let nb = List.map f b.bstmts in
              if !first then
                b.bstmts <- label :: b.bstmts
              else
                b.bstmts <- nb;
              stmt
            | _ -> assert false
          end
        )
    | _ ->
      Cil.DoChildren
end

(** Create a pc_label_sequence *)
let mkSeq (sid : int) (lid : int) (nb : int) : Cil_types.stmt =
  let idExp = Exp.kinteger IULong sid in
  let oneExp = Exp.one () in
  let curr = Exp.integer nb in
  let slen = Exp.integer 2 in
  let varExp = Exp.string (string_of_int lid) in
  let zeroExp = Exp.zero () in
  Utils.mk_call "pc_label_sequence" ([oneExp;idExp;curr;slen;varExp;zeroExp])

(** Create a pc_label_sequence_condiion *)
let mkCond (sid : int) : Cil_types.stmt =
  let zeroExp = Exp.zero () in
  let ccExp = Exp.string (string_of_int sid) in
  Utils.mk_call "pc_label_sequence_condition" ([zeroExp;ccExp])

(** Add a label in each loop, to see if we enter in it *)
let outter () = object(_)
  inherit Visitor.frama_c_inplace

  (** Pile qui stock le status des boucles *)
  val inLoopId = Stack.create ()

  method! vfunc dec =
    if Annotators.shouldInstrument dec.svar then
      Cil.DoChildren
    else
      Cil.SkipChildren

  method! vstmt_aux stmt =
    match stmt.skind with
    | Loop (_,_,l,_,_) ->
      let sid = Annotators.next () in
      let set = mkSeq sid stmt.sid 1 in
      let use = mkSeq sid stmt.sid 2 in
      let cond = mkCond stmt.sid in
      idsList := sid :: !idsList;
      Cil.DoChildrenPost (fun stmt ->
          let newLoop =
            match stmt.skind with
            | Loop (ca,b,l,s1,s2) ->
              let first = ref true in
              (* Looking for the if generated by frama-c (if it exists) *)
              let f s =
                match s.skind with
                | If (e,th,el,l) ->
                  if !first && th.bstmts = [] && is_break_only el.bstmts then begin
                    s.skind <- (If (e,{th with bstmts = [cond]},el,l));
                    first := false
                  end;
                  s
                | _ -> s
              in
              let nb = List.map f b.bstmts in
              if !first then
                b.bstmts <- cond :: b.bstmts
              else
                b.bstmts <- nb;
              stmt
            | _ -> assert false
          in
          Stmt.block [set;newLoop;use]
        )
    | _ ->
      Cil.DoChildren
end

(** Use idList to create all hyprlabels *)
let compute_hl () : string =
    List.fold_left (fun str ids -> "<s" ^ string_of_int ids ^"|; ;>,\n" ^ str) "" !idsList

let gen_hyperlabels () =
  let data_filename = (Filename.chop_extension (Annotators.get_file_name ())) ^ ".hyperlabels" in
  Options.feedback "write hyperlabel data (to %s)" data_filename;
  let data = compute_hl () in
  let out = open_out_gen [Open_creat; Open_append] 0o640 data_filename in
  output_string out data;
  close_out out;
  Options.feedback "Total number of labels = %d" ((List.length !idsList)*3)

include Annotators.Register (struct

    let name = "LOOPIN"
    let help = "Enter in Loop Coverage"

    let apply mk_label ast =
      Options.warning "This criteria can only handle For,While and Do...while(true) loops. \
                     Do...While(condition) are not supported";
      Visitor.visitFramacFileSameGlobals (inner mk_label) ast
  end)

include Annotators.Register (struct

    let name = "LOOPOUT"
    let help = "Skip Loop Coverage"

    let apply mk_label ast =
      Options.warning "This criteria can only handle For, While and Do...while(true) loops. \
                     Do...While(condition) are not supported";
      Visitor.visitFramacFileSameGlobals (outter ()) ast;
      gen_hyperlabels ()
  end)
